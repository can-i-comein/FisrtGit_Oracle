-- 데이터 타입
-- 문자 : CHAR, VARCHAR2
-- CHAR : 고정 길이 문자열 (~2000BYTE)
-- VARCHAR2 : 가변 길이 문자열 (~4000BYTE)
-- 크기 지정 시 기본적으로 BYTE로 지정, CHAR로 명시해서도 들어갈 수 있음
-- EX. CHAR(3), CHAR(3BYTE) : 3 BYTE만큼만 들어가게
--      ABC, 123, 짱
-- EX. CHAR(3CHAR) : 3글자가 들어가게
--      ABC, 123, 박신우
-- CHAR VS VARCHAR2
-- EX. CHAR(1OCHAR) : 안녕하세요_ _ _ _ _
-- EX. VARCHAR2(10CHAR) : 안녕하세요
-- 숫자 : NUMBER
-- 날짜 : DATE


-- CREATE : 객체를 생성하는 구문
CREATE TABLE MEMBER(
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(20),
    MEMBER_NAME VARCHAR2(20)
);

COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원 아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원 패스워드';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원 이름';


-- 제약조건 : 테이블 작성 시 각 컬럼에 값 기록에 대한 제약조건 설정 가능
-- 데이터 무결성 보장을 목적으로 함
-- 데이터 무결성 : 데이터 정확성, 일관성, 유효성이 유지되는 것

-- NOT NULL : 컬럼에 반드시 값이 기록되어야 하는 경우 사용
CREATE TABLE USER_NOCONST(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_NOCONST VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_NOCONST VALUES(NULL, NULL, NULL, NULL, NULL, NULL, NULL);

CREATE TABLE USER_NOTNULL(
    USER_NO NUMBER NOT NULL,
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_NOTNULL VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_NOTNULL VALUES(2, 'USER02', 'PASS02', '남나눔', NULL, NULL, NULL);


-- UNIQUE : 컬럼 값에 대해서 중복을 제한하는 제약조건
CREATE TABLE USER_UNIQUE(
    USER_NO NUMBER UNIQUE, -- 컬럼레벨에서 제약조건 설정
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_ID) -- 테이블레벨 제약조건 설정
);

INSERT INTO USER_UNIQUE VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_UNIQUE VALUES(2, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');

SELECT UCC.TABLE_NAME, UCC.COLUMN_NAME, UC.CONSTRAINT_TYPE
FROM USER_CONSTRAINTS UC, USER_CONS_COLUMNS UCC
WHERE UCC.CONSTRAINT_NAME = UC.CONSTRAINT_NAME
        AND UCC.CONSTRAINT_NAME = 'SYS_C007323';

CREATE TABLE USER_UNIQUE2(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_NO, USER_ID) -- 테이블레벨 제약조건 설정 (한 묶음으로 봄)
);

-- 테이블레벨에서 제약조건을 설정하여 한묶음으로 보기 때문에 아래 INSERT 모두 실행 가능
INSERT INTO USER_UNIQUE2 VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_UNIQUE2 VALUES(2, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_UNIQUE2 VALUES(1, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_UNIQUE2 VALUES(2, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');

-- 제약조건에 이름을 붙이고 싶으면 제약조건 앞에 적으면 됨
CREATE TABLE CONS_NAME(
    TEST_DATA1 VARCHAR2(20) CONSTRAINT NN_CN_TD1 NOT NULL,
    TEST_DATA2 VARCHAR2(20) CONSTRAINT UQ_NN_TD2 UNIQUE,
    TEST_DATA3 VARCHAR2(20),
    CONSTRAINT UK_CN_TD3 UNIQUE(TEST_DATA3)
);

INSERT INTO CONS_NAME VALUES('TEST1', 'TEST2', 'TEST3');
-- 왜 되는지?

SELECT *
FROM USER_CONSTRAINTS C1
    JOIN USER_CONS_COLUMNS C2 USING(CONSTRAINT_NAME)
WHERE C1.TABLE_NAME = 'CONS_NAME';

-- PRIMARY KEY : NOT NULL + UNIQUE
-- 테이블에 대한 식별자 역할 (한테이블당 1개만)
CREATE TABLE USER_PRIMARYKEY(
    USER_NO NUMBER CONSTRAINT PK_UP_NO PRIMARY KEY, -- 컬럼 레벨
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_PRIMARYKEY VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_PRIMARYKEY -- 무결성 제약조건에 위배
VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_PRIMARYKEY -- NOT NULL 제약조건에 위배
VALUES(NULL, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');


CREATE TABLE USER_PRIMARYKEY2(
    USER_NO NUMBER, 
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    CONSTRAINT PK_UP2_NOID PRIMARY KEY(USER_NO, USER_ID)
);
-- 묶어놨기 때문에 아래 모두 처리가능
INSERT INTO USER_PRIMARYKEY2 VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_PRIMARYKEY2 VALUES(2, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_PRIMARYKEY2 VALUES(1, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_PRIMARYKEY2 VALUES(NULL, 'USER02', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');







-- FOREIGN KEY : 참조하고 있는 다른 테이블의 컬럼이 제공하는 값만 사용하게 하는 제약조건
-- 조인은 데이터만 같으면 되고, 참조 여부와 상관없음
-- 테이블 간의 관계 형성, 참조컬럼은 PRIMARY KEY나 UNIQUE가 들어가있는 컬럼만 가능
CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_GRADE VALUES(10, '일반회원');
INSERT INTO USER_GRADE VALUES(20, '우수회원');
INSERT INTO USER_GRADE VALUES(30, '특별회원');


CREATE TABLE USER_FOREIGNKEY(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER CONSTRAINT FK_UF_GC REFERENCES USER_GRADE(GRADE_CODE) -- 컬럼 레벨
);

INSERT INTO USER_FOREIGNKEY VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR',10);
INSERT INTO USER_FOREIGNKEY VALUES(2, 'USER02', 'PASS01', '남나눔', '남', '010-3333-4444', 'NAM123@KH.OR.KR',10);
INSERT INTO USER_FOREIGNKEY VALUES(3, 'USER03', 'PASS03', '도대담', '남', '010-5555-6666', 'KANG123@KH.OR.KR',30);
INSERT INTO USER_FOREIGNKEY VALUES(4, 'USER04', 'PASS04', '류라라', '여', '010-7777-8888', 'RYU123@KH.OR.KR',NULL);
INSERT INTO USER_FOREIGNKEY VALUES(5, 'USER05', 'PASS05', '문미미', '여', '010-9999-0000', 'MOON123@KH.OR.KR',50);

COMMIT; -- 상태 확정 / 상태 되돌리기 ROLLBACK; (마지막으로 COMMIT한 시점)

DELETE FROM USER_GRADE
WHERE GRADE_CODE = 20;

-- 자식레코드가 있으면 삭제할 수 없음
DELETE FROM USER_GRADE
WHERE GRADE_CODE = 10;

ROLLBACK;







CREATE TABLE USER_GRADE2(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_GRADE2 VALUES(10, '일반회원');
INSERT INTO USER_GRADE2 VALUES(20, '우수회원');
INSERT INTO USER_GRADE2 VALUES(30, '특별회원');

CREATE TABLE USER_FOREIGNKEY2(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_UF2_GC FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE2(GRADE_CODE) ON DELETE SET NULL
    -- ON DELETE SET NULL : 부모키 삭제 시 자식키를 NULL로 변경
);

INSERT INTO USER_FOREIGNKEY2 VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR',10);
INSERT INTO USER_FOREIGNKEY2 VALUES(2, 'USER02', 'PASS01', '남나눔', '남', '010-3333-4444', 'NAM123@KH.OR.KR',10);
INSERT INTO USER_FOREIGNKEY2 VALUES(3, 'USER03', 'PASS03', '도대담', '남', '010-5555-6666', 'KANG123@KH.OR.KR',30);
INSERT INTO USER_FOREIGNKEY2 VALUES(4, 'USER04', 'PASS04', '류라라', '여', '010-7777-8888', 'RYU123@KH.OR.KR',NULL);

COMMIT;

SELECT * FROM USER_GRADE2;
SELECT * FROM USER_FOREIGNKEY2;

DELETE FROM USER_GRADE2 WHERE GRADE_CODE = 10;

ROLLBACK;





CREATE TABLE USER_GRADE3(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_GRADE3 VALUES(10, '일반회원');
INSERT INTO USER_GRADE3 VALUES(20, '우수회원');
INSERT INTO USER_GRADE3 VALUES(30, '특별회원');

CREATE TABLE USER_FOREIGNKEY3(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_UF3_GC FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE3(GRADE_CODE) ON DELETE CASCADE
    -- ON DELETE CASCADE : 부모키가 삭제되면 참조하고 있는 자식도 모두 삭제
);

INSERT INTO USER_FOREIGNKEY3 VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR',10);
INSERT INTO USER_FOREIGNKEY3 VALUES(2, 'USER02', 'PASS01', '남나눔', '남', '010-3333-4444', 'NAM123@KH.OR.KR',10);
INSERT INTO USER_FOREIGNKEY3 VALUES(3, 'USER03', 'PASS03', '도대담', '남', '010-5555-6666', 'KANG123@KH.OR.KR',30);
INSERT INTO USER_FOREIGNKEY3 VALUES(4, 'USER04', 'PASS04', '류라라', '여', '010-7777-8888', 'RYU123@KH.OR.KR',NULL);

COMMIT;

SELECT * FROM USER_GRADE3;
SELECT * FROM USER_FOREIGNKEY3;

DELETE FROM USER_GRADE3 WHERE GRADE_CODE = 10;

ROLLBACK;







-- CHECK : 컬럼에 기록되는 값에 대해 범위 조건 설정
CREATE TABLE USER_CHECK(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남', '여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_CHECK VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR');
INSERT INTO USER_CHECK VALUES(2, 'USER02', 'PASS01', '남나눔', '남자', '010-3333-4444', 'NAM123@KH.OR.KR');

CREATE TABLE USER_CHECK2(
    C_NAME VARCHAR2(15 CHAR),
--  C_PRICE NUMBER CONSTRAINT CK_UC2_PRICE CHECK(C_PRICE >= 1 AND C_PRICE <= 99999),
    C_PRICE NUMBER CONSTRAINT CK_UC2_PRICE CHECK(C_PRICE BETWEEN 1 AND 99999),
    C_LEVEL CHAR(1),
    C_DATE DATE,
    CONSTRAINT CK_UC2_LEVEL CHECK(C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
    CONSTRAINT CK_UC2_DATE CHECK(C_DATE >= TO_DATE('2020/01/01', 'YYYY/MM/DD'))
);


/*
    [실습 문제]
    회원가입용 테이블 생성 : USER_TEST
    컬럼명
        USER_NO (회원번호) : NUMBER             - 기본키(PK_UT_USERNO)
        USER_ID (회원아이디) : VARCHAR2(20)      - 중복금지(UQ_UT_USERID)
        USER_PWD (회원비밀번호) : VARCHAR2(20)    - NULL 허용안함(NN_UT_USERPWD)
        PNO     (주민등록번호): VARCHAR2(20)      - 중복금지(UQ_UT_PNO), NULL 허용안함(NN_UT_PNO)
        GENDER  (성별)       : VARCHAR2(3)       - 남 혹은 여로 입력(CK_UT_GENDER)
        PHONE   (연락처)      : VARCHAR2(20)  
        ADDRESS (주소)        : VARCHAR2(100)
        STATUS (탈퇴여부)      : VARCHAR2(3)     - NULL 허용안함(NN_UT_STATUS), Y 또는 N으로 입력(CK_UT_STATUS)
        
        * 각 컬럼에 제약조건이 있으면 제약조건 넣고, 제약조건의 이름까지 부여
        * 컬럼 주석 넣기 (소괄호 내용 활용)
        * 5명 이상 INSERT 하기 
*/

CREATE TABLE USER_TEST(
    USER_NO NUMBER CONSTRAINT PK_UT_USERNO PRIMARY KEY,
    USER_ID VARCHAR2(20) CONSTRAINT UQ_UT_USERID UNIQUE,
    USER_PWD VARCHAR2(20) CONSTRAINT NN_UT_USERPWD NOT NULL,
    PNO VARCHAR2(20) CONSTRAINT NN_UT_PNO NOT NULL,
    GENDER VARCHAR2(3) CONSTRAINT CK_UT_GENDER CHECK(GENDER IN('남', '여')),
    PHONE VARCHAR2(20),
    ADDRESS VARCHAR2(100),
    STATUS  VARCHAR2(3) CONSTRAINT NN_UT_STATUS NOT NULL,
    CONSTRAINT UQ_UT_PNO UNIQUE(PNO),
    CONSTRAINT CK_UT_STATUS CHECK(STATUS IN('Y','N'))
);
COMMENT ON COLUMN USER_TEST.USER_NO IS '회원번호';
COMMENT ON COLUMN USER_TEST.USER_ID IS '회원아이디';
COMMENT ON COLUMN USER_TEST.USER_PWD IS '회원비밀번호';
COMMENT ON COLUMN USER_TEST.PNO IS '주민등록번호';
COMMENT ON COLUMN USER_TEST.GENDER IS '성별';
COMMENT ON COLUMN USER_TEST.PHONE IS '연락처';
COMMENT ON COLUMN USER_TEST.ADDRESS IS '주소';
COMMENT ON COLUMN USER_TEST.STATUS IS '탈퇴여부';

INSERT INTO USER_TEST VALUES(1, 'USER01', 'PASS01', '강건강', '남', '010-1111-2222', 'KANG123@KH.OR.KR','Y');
INSERT INTO USER_TEST VALUES(2, 'USER02', 'PASS01', '남나눔', '남', '010-3333-4444', 'NAM123@KH.OR.KR','N');
INSERT INTO USER_TEST VALUES(3, 'USER03', 'PASS03', '도대담', '남', '010-5555-6666', 'KANG123@KH.OR.KR','Y');
INSERT INTO USER_TEST VALUES(4, 'USER04', 'PASS04', '류라라', '여', '010-7777-8888', 'RYU123@KH.OR.KR', 'N');
INSERT INTO USER_TEST VALUES(5, 'SEAN', 'ABAB123', '황인호', '남', '010-4051-1770', 'SEAN@NAVER.COM', 'Y');

SELECT * 
FROM USER_TEST;


