-- DML : 데이터 조작 언어 (INSERT, UPDATE, DELETE)
--      데이터를 삽입(INSERT), 수정(UPDATE), 삭제(DELETE)하는 구문
-- INSERT
INSERT INTO EMPLOYEE
VALUES(900, '강건강', '990909-1547824', 'KANG@KH.CO.KR', '01011112222', 'D1', 'J7', 'S3',
        3000000, 0.2, 200, SYSDATE, NULL, 'N');
        
SELECT * FROM EMPLOYEE WHERE EMP_NAME = '강건강';
-- 1) INSERT INTO 테이블명 VALUES(데이터1, 데이터2, 데이터3, ....);
-- 2) INSERT INTO 테이블명(컬럼명1, 컬럼명2, 컬럼명3,..) VALUES(데이터1, 데이터2, 데이터3, ....);
-- 1번은 테이블의 컬럼 순서를 다 외우고 있어야 거기에 맞게 데이터 삽입 가능
-- 2번은 컬럼명에 맞게 데이터 삽입 가능
-- 1번은 무조건 컬럼 전체에 데이터 삽입
-- 2번은 지정한 컬럼에 데이터 삽입 > 지정하지 않은 컬럼에는 자동으로 NULL / DEFAULT VALUE
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, DEPT_CODE, SALARY, SAL_LEVEL, MANAGER_ID,
                    BONUS, HIRE_DATE, ENT_DATE, ENT_YN, EMAIL, PHONE)
        VALUES(901, '도대담', '880514-174453', 'D2', 'J7', 2700000, 'S3', 200, 0.1, SYSDATE
                , NULL, 'N', 'DAH@KH.CO.KR', '01022223333');
                
INSERT INTO EMPLOYEE(EMP_ID, SAL_LEVEL, JOB_CODE, EMP_NO, EMP_NAME)
VALUES(902, 'S2', 'J2', '971221-1234421', '대한건아');

COMMIT;

INSERT INTO CONS_NAME(
    SELECT EMP_ID, EMP_NAME, EMP_NO
    FROM EMPLOYEE;
);

CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE;

CREATE TABLE EMPLOYEE_COPY2
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE, JOB_NAME
    FROM EMPLOYEE
        LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
        JOIN JOB USING(JOB_CODE);
        
-- INSERT ALL
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
    FROM EMPLOYEE
    WHERE 1=0;


INSERT ALL
INTO EMP_DEPT_D1 VALUES()


-- EMPLOYEE테이블의 입사일 기준으로 2000년 1월 1일 이전에 입사한 사원의 정보는 EMP_OLD에 삽입
-- 2000년 1월 1일 이후에 입사한 사원의 정보는 EMP_NEW에 삽입
CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1=0;
    
CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1=0;

INSERT ALL
WHEN HIRE_DATE < '2000/01/01' THEN INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
WHEN HIRE_DATE >= '2000/01/01' THEN INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE;

COMMIT;
ROLLBACK;

-- UPDATE
-- UPDATE 테이블명 SET 컬럼명=바꿀값, 컬럼명=바꿀값 [WHERE 조건];
-- EMPLOYEE_COPY테이블에서 DEPT_CODE가 D9인 행의 SALARY를 0으로 수정
UPDATE EMPLOYEE_COPY
SET SALARY = 0
WHERE DEPT_CODE = 'D9';

SELECT * FROM EMPLOYEE_COPY WHERE EMP_NAME IN ('유재식', '방명수');

UPDATE EMPLOYEE_COPY
SET SALARY=(SELECT SALARY FROM EMPLOYEE_COPY WHERE EMP_NAME = '유재식'), 
    BONUS=(SELECT SALARY FROM EMPLOYEE_COPY WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수';

SELECT * FROM EMPLOYEE_COPY WHERE EMP_NAME IN ('유재식', '노옹철', '하동운', '전형돈', '정중하');
UPDATE EMPLOYEE_COPY
SET (SET, SALARY) = (SELECT BONUS, SALARY
                        FROM EMPLOYEE_COPY
                        WHERE EMP_NAME = '유재식')
WHERE EMP_NAME IN ('노옹철', '하동운', '전형돈', '정중하');

COMMIT;

UPDATE EMPLOYEE SET EMP_NAME = NULL;
UPDATE CONS_NAME SET TEST_DATA2 = '강건강';

-- DELETE
SELECT * FROM EMPLOYEE;

DELETE FROM EMPLOYEE
WHERE EMP_NAME = '강건강';

ROLLBACK;


--제약조건을 비활성화하면 삭제할 수 있다.
DELETE FROM USER_GRADE WHERE GRADE_CODE = 10;

ALTER TABLE USER_FOREIGNKEY
DISABLE CONSTRAINT FK_UF_GC CASCADE; -- 제약조건 비활성화

SELECT * FROM USER_GRADE;
SELECT * FROM USER_FOREIGNKEY;

ROLLBACK;

ALTER TABLE USER_FOREIGNKEY
ENABLE CONSTRAINT FK_UF_GC; -- 제약조건 다시 활성화

COMMIT;


SELECT * FROM EMP_DEPT_D1;

DELETE FROM EMP_DEPT_D1;

ROLLBACK;

TRUNCATE TABLE EMP_DEPT_D1;
-- TRUNCATE : 테이블의 전체행 삭제
-- ROLLBACK을 통해 복구 불가, DELETE보다 수행속도가 빠름













